#!/usr/bin/env tsx
import { readdir } from "node:fs/promises";
import { writeFile } from "node:fs/promises";
import * as path from "node:path";
import { fileURLToPath } from "node:url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function generateMigrationsIndex() {
	const migrationsDir = path.resolve(__dirname, "../src/migrations");
	const indexPath = path.join(migrationsDir, "index.ts");

	// Read all migration files
	const files = await readdir(migrationsDir);
	const migrationFiles = files
		.filter((file) => file.endsWith(".ts") && file !== "index.ts")
		.sort(); // Sort to ensure consistent order

	if (migrationFiles.length === 0) {
		console.log("⚠️  No migration files found");
		return;
	}

	// Generate imports and exports using the filename without .ts
	const entries = migrationFiles.map((file) => {
		const name = file.replace(".ts", "");
		return {
			importPath: `./${name}.js`,
			migrationName: name,
		};
	});

	// Build the content without intermediate variables
	const imports = entries.map((e) => `import * as migration_${e.migrationName.replace(/-/g, "_")} from "${e.importPath}";`);
	const migrations = entries.map((e) => `\t"${e.migrationName}": migration_${e.migrationName.replace(/-/g, "_")},`);

	// Generate file content
	const content = `// This file is auto-generated by scripts/generate-migrations-index.ts
// Do not edit manually - run 'pnpm db:generate-index' to regenerate
import type { Migration } from "kysely";
${imports.join("\n")}

export const migrations: Record<string, Migration> = {
${migrations.join("\n")}
};
`;

	// Write to file
	await writeFile(indexPath, content, "utf-8");

	console.log("✅ Generated migrations index with", migrationFiles.length, "migrations:");
	for (const file of migrationFiles) {
		console.log(`   - ${file}`);
	}
}

generateMigrationsIndex().catch((error) => {
	console.error("❌ Failed to generate migrations index:", error);
	process.exit(1);
});
